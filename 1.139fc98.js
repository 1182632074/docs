webpackJsonp([1],{128:function(t,s,n){t.exports=n(258),'<h1>Loadmore</h1>\n<blockquote>\n<p>下拉/上拉刷新，支持自定义 HTML 模板。</p>\n</blockquote>\n<hr>\n<h2>引入</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { Loadmore } <span class="hljs-keyword">from</span> <span class="hljs-string">\'mint-ui\'</span>;\n\nVue.component(Loadmore.name, Loadmore);\n</code></pre>\n<h2>例子</h2>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">mt-loadmore</span> <span class="hljs-attr">:top-method</span>=<span class="hljs-string">"loadTop"</span> <span class="hljs-attr">:bottom-method</span>=<span class="hljs-string">"loadBottom"</span> <span class="hljs-attr">:bottom-all-loaded</span>=<span class="hljs-string">"allLoaded"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"loadmore"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">mt-loadmore</span>&gt;</span>\n</code></pre>\n<p>以列表顶部的下拉刷新为例：按住列表，下拉一定距离（通过 <code>topDistance</code> 配置）后释放，被指定为 <code>top-method</code> 的方法就会执行</p>\n<pre><code class="language-javascript">loadTop(id) {\n  ...<span class="hljs-comment">// 加载更多数据</span>\n  <span class="hljs-keyword">this</span>.$refs.loadmore.onTopLoaded(id);\n}\n</code></pre>\n<p>注意在这个方法的最后需要手动调用 <code>loadmore</code> 的 <code>onTopLoaded</code> 事件，参数为 <code>id</code>。这是因为在加载数据后需要对组件进行一些重新定位的操作，<code>id</code> 参数能够避免在同一页面有多个 <code>loadmore</code> 实例时互相干扰。</p>\n<p>列表底部的上拉刷新与之类似</p>\n<pre><code class="language-javascript">loadBottom(id) {\n  ...<span class="hljs-comment">// 加载更多数据</span>\n  <span class="hljs-keyword">this</span>.allLoaded = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 若数据已全部获取完毕</span>\n  <span class="hljs-keyword">this</span>.$refs.loadmore.onBottomLoaded(id);\n}\n</code></pre>\n<p>唯一的区别是，当底部数据全部获取完毕时，可以将绑定到组件 <code>bottom-all-loaded</code> 属性的变量赋值为 <code>true</code>，这样 <code>bottom-method</code> 就不会再次执行了。</p>\n<p>手指在屏幕上滑动的距离与组件实际移动的距离比值可以通过 <code>distance-index</code> 参数配置，默认值为 2。</p>\n<h2>自定义 HTML 模板</h2>\n<p>可以为列表顶部和底部的加载提示区域提供自定义的 HTML 模板</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">mt-loadmore</span> <span class="hljs-attr">:top-method</span>=<span class="hljs-string">"loadTop"</span> @<span class="hljs-attr">top-status-change</span>=<span class="hljs-string">"handleTopChange"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"top"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mint-loadmore-top"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"topStatus !== \'loading\'"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ \'rotate\': topStatus === \'drop\' }"</span>&gt;</span>↓<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"topStatus === \'loading\'"</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">mt-loadmore</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data() {\n      <span class="hljs-keyword">return</span> {\n        topStatus: <span class="hljs-string">\'\'</span>,\n        <span class="hljs-comment">// ...</span>\n      };\n    },\n    methods: {\n      handleTopChange(status) {\n        <span class="hljs-keyword">this</span>.topStatus = status;\n      },\n      <span class="hljs-comment">// ...</span>\n    },\n    <span class="hljs-comment">// ...</span>\n  };\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>比如需要配置列表顶部的 HTML，则需要为自定义 HTML 模板的最外层标签设置 <code>slot</code> 属性为 <code>top</code>，类名为 <code>mint-loadmore-top</code>。当用户滑动组件时，组件会有以下几个状态：</p>\n<ul>\n<li><code>pull</code>：组件已经被按下，但按下的距离未达到 <code>topDistance</code>，此时释放不会触发 <code>top-method</code>，列表会回到初始位置</li>\n<li><code>drop</code>：按下的距离不小于 <code>topDistance</code>，此时释放会触发 <code>top-method</code></li>\n<li><code>loading</code>：组件已被释放，<code>top-method</code> 正在执行\n每当组件的状态发生变化时，<code>loadmore</code> 都会触发 <code>top-status-change</code> 方法，参数为组件目前的状态。因此可以像本例一样，使用一个 <code>handleTopChange</code> 方法来处理组件状态的变化。</li>\n</ul>\n<h2>配置加载提示区域的文字</h2>\n<p>在不使用自定义 HTML 模板的情况下，可以配置 <code>loadmore</code> 本身自带的加载提示区域的文字。以列表顶部为例，对应于 <code>status</code> 的三个状态，可配置的属性依次为 <code>topPullText</code>、<code>topDropText</code> 和 <code>topLoadingText</code>。与之对应的底部属性为 <code>bottomPullText</code>、<code>bottomDropText</code> 和 <code>bottomLoadingText</code>。</p>\n<h2>自动检测</h2>\n<p><code>loadmore</code> 在初始化时会自动检测它的高度是否能够撑满其容器，如果不能则会调用 <code>bottom-method</code>，直到撑满容器为止。如果不希望使用这一机制，可以将 <code>auto-fill</code> 设为 <code>false</code>。</p>\n<h2>API</h2>\n<div class="table-container"><table class="table"><thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>类型</th>\n<th>可选值</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>autoFill</td>\n<td>若为真，<code>loadmore</code> 会自动检测并撑满其容器</td>\n<td>Boolean</td>\n<td></td>\n<td>true</td>\n</tr>\n<tr>\n<td>distanceIndex</td>\n<td>手指移动与组件移动距离的比值</td>\n<td>Number</td>\n<td></td>\n<td>2</td>\n</tr>\n<tr>\n<td>maxDistance</td>\n<td>组件可移动的最大距离（像素），若为 0 则不限制</td>\n<td>Number</td>\n<td></td>\n<td>0</td>\n</tr>\n<tr>\n<td>topPullText</td>\n<td><code>topStatus</code> 为 <code>pull</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'下拉刷新\'</td>\n</tr>\n<tr>\n<td>topDropText</td>\n<td><code>topStatus</code> 为 <code>drop</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'释放更新\'</td>\n</tr>\n<tr>\n<td>topLoadingText</td>\n<td><code>topStatus</code> 为 <code>loading</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'加载中...\'</td>\n</tr>\n<tr>\n<td>topDistance</td>\n<td>触发 <code>topMethod</code> 的下拉距离阈值（像素）</td>\n<td>Number</td>\n<td></td>\n<td>70</td>\n</tr>\n<tr>\n<td>topMethod</td>\n<td>下拉刷新执行的方法</td>\n<td>Function</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>bottomPullText</td>\n<td><code>bottomStatus</code> 为 <code>pull</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'上拉刷新\'</td>\n</tr>\n<tr>\n<td>bottomDropText</td>\n<td><code>bottomStatus</code> 为 <code>drop</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'释放更新\'</td>\n</tr>\n<tr>\n<td>bottomLoadingText</td>\n<td><code>bottomStatus</code> 为 <code>loading</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'加载中...\'</td>\n</tr>\n<tr>\n<td>bottomDistance</td>\n<td>触发 <code>bottomMethod</code> 的上拉距离阈值（像素）</td>\n<td>Number</td>\n<td></td>\n<td>70</td>\n</tr>\n<tr>\n<td>bottomMethod</td>\n<td>上拉刷新执行的方法</td>\n<td>Function</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>bottomAllLoaded</td>\n<td>若为真，则 <code>bottomMethod</code> 不会被再次触发</td>\n<td>Boolean</td>\n<td></td>\n<td>false</td>\n</tr>\n</tbody>\n</table></div><h2>Events</h2>\n<div class="table-container"><table class="table"><thead>\n<tr>\n<th>事件名称</th>\n<th>说明</th>\n<th>回调参数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>top-status-change</td>\n<td>组件顶部状态发生变化时的回调函数</td>\n<td>组件顶部的新状态名</td>\n</tr>\n<tr>\n<td>bottom-status-change</td>\n<td>组件底部状态发生变化时的回调函数</td>\n<td>组件底部的新状态名</td>\n</tr>\n</tbody>\n</table></div><h2>Slot</h2>\n<div class="table-container"><table class="table"><thead>\n<tr>\n<th>name</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-</td>\n<td>数据列表</td>\n</tr>\n<tr>\n<td>top</td>\n<td>自定义顶部加载提示区域 HTML 模板</td>\n</tr>\n<tr>\n<td>bottom</td>\n<td>自定义底部加载提示区域 HTML 模板</td>\n</tr>\n</tbody>\n</table></div>'!==t.exports.template&&(t.exports.template='<h1>Loadmore</h1>\n<blockquote>\n<p>下拉/上拉刷新，支持自定义 HTML 模板。</p>\n</blockquote>\n<hr>\n<h2>引入</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { Loadmore } <span class="hljs-keyword">from</span> <span class="hljs-string">\'mint-ui\'</span>;\n\nVue.component(Loadmore.name, Loadmore);\n</code></pre>\n<h2>例子</h2>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">mt-loadmore</span> <span class="hljs-attr">:top-method</span>=<span class="hljs-string">"loadTop"</span> <span class="hljs-attr">:bottom-method</span>=<span class="hljs-string">"loadBottom"</span> <span class="hljs-attr">:bottom-all-loaded</span>=<span class="hljs-string">"allLoaded"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"loadmore"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">mt-loadmore</span>&gt;</span>\n</code></pre>\n<p>以列表顶部的下拉刷新为例：按住列表，下拉一定距离（通过 <code>topDistance</code> 配置）后释放，被指定为 <code>top-method</code> 的方法就会执行</p>\n<pre><code class="language-javascript">loadTop(id) {\n  ...<span class="hljs-comment">// 加载更多数据</span>\n  <span class="hljs-keyword">this</span>.$refs.loadmore.onTopLoaded(id);\n}\n</code></pre>\n<p>注意在这个方法的最后需要手动调用 <code>loadmore</code> 的 <code>onTopLoaded</code> 事件，参数为 <code>id</code>。这是因为在加载数据后需要对组件进行一些重新定位的操作，<code>id</code> 参数能够避免在同一页面有多个 <code>loadmore</code> 实例时互相干扰。</p>\n<p>列表底部的上拉刷新与之类似</p>\n<pre><code class="language-javascript">loadBottom(id) {\n  ...<span class="hljs-comment">// 加载更多数据</span>\n  <span class="hljs-keyword">this</span>.allLoaded = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 若数据已全部获取完毕</span>\n  <span class="hljs-keyword">this</span>.$refs.loadmore.onBottomLoaded(id);\n}\n</code></pre>\n<p>唯一的区别是，当底部数据全部获取完毕时，可以将绑定到组件 <code>bottom-all-loaded</code> 属性的变量赋值为 <code>true</code>，这样 <code>bottom-method</code> 就不会再次执行了。</p>\n<p>手指在屏幕上滑动的距离与组件实际移动的距离比值可以通过 <code>distance-index</code> 参数配置，默认值为 2。</p>\n<h2>自定义 HTML 模板</h2>\n<p>可以为列表顶部和底部的加载提示区域提供自定义的 HTML 模板</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">mt-loadmore</span> <span class="hljs-attr">:top-method</span>=<span class="hljs-string">"loadTop"</span> @<span class="hljs-attr">top-status-change</span>=<span class="hljs-string">"handleTopChange"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"top"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mint-loadmore-top"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"topStatus !== \'loading\'"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ \'rotate\': topStatus === \'drop\' }"</span>&gt;</span>↓<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"topStatus === \'loading\'"</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">mt-loadmore</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data() {\n      <span class="hljs-keyword">return</span> {\n        topStatus: <span class="hljs-string">\'\'</span>,\n        <span class="hljs-comment">// ...</span>\n      };\n    },\n    methods: {\n      handleTopChange(status) {\n        <span class="hljs-keyword">this</span>.topStatus = status;\n      },\n      <span class="hljs-comment">// ...</span>\n    },\n    <span class="hljs-comment">// ...</span>\n  };\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>比如需要配置列表顶部的 HTML，则需要为自定义 HTML 模板的最外层标签设置 <code>slot</code> 属性为 <code>top</code>，类名为 <code>mint-loadmore-top</code>。当用户滑动组件时，组件会有以下几个状态：</p>\n<ul>\n<li><code>pull</code>：组件已经被按下，但按下的距离未达到 <code>topDistance</code>，此时释放不会触发 <code>top-method</code>，列表会回到初始位置</li>\n<li><code>drop</code>：按下的距离不小于 <code>topDistance</code>，此时释放会触发 <code>top-method</code></li>\n<li><code>loading</code>：组件已被释放，<code>top-method</code> 正在执行\n每当组件的状态发生变化时，<code>loadmore</code> 都会触发 <code>top-status-change</code> 方法，参数为组件目前的状态。因此可以像本例一样，使用一个 <code>handleTopChange</code> 方法来处理组件状态的变化。</li>\n</ul>\n<h2>配置加载提示区域的文字</h2>\n<p>在不使用自定义 HTML 模板的情况下，可以配置 <code>loadmore</code> 本身自带的加载提示区域的文字。以列表顶部为例，对应于 <code>status</code> 的三个状态，可配置的属性依次为 <code>topPullText</code>、<code>topDropText</code> 和 <code>topLoadingText</code>。与之对应的底部属性为 <code>bottomPullText</code>、<code>bottomDropText</code> 和 <code>bottomLoadingText</code>。</p>\n<h2>自动检测</h2>\n<p><code>loadmore</code> 在初始化时会自动检测它的高度是否能够撑满其容器，如果不能则会调用 <code>bottom-method</code>，直到撑满容器为止。如果不希望使用这一机制，可以将 <code>auto-fill</code> 设为 <code>false</code>。</p>\n<h2>API</h2>\n<div class="table-container"><table class="table"><thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>类型</th>\n<th>可选值</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>autoFill</td>\n<td>若为真，<code>loadmore</code> 会自动检测并撑满其容器</td>\n<td>Boolean</td>\n<td></td>\n<td>true</td>\n</tr>\n<tr>\n<td>distanceIndex</td>\n<td>手指移动与组件移动距离的比值</td>\n<td>Number</td>\n<td></td>\n<td>2</td>\n</tr>\n<tr>\n<td>maxDistance</td>\n<td>组件可移动的最大距离（像素），若为 0 则不限制</td>\n<td>Number</td>\n<td></td>\n<td>0</td>\n</tr>\n<tr>\n<td>topPullText</td>\n<td><code>topStatus</code> 为 <code>pull</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'下拉刷新\'</td>\n</tr>\n<tr>\n<td>topDropText</td>\n<td><code>topStatus</code> 为 <code>drop</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'释放更新\'</td>\n</tr>\n<tr>\n<td>topLoadingText</td>\n<td><code>topStatus</code> 为 <code>loading</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'加载中...\'</td>\n</tr>\n<tr>\n<td>topDistance</td>\n<td>触发 <code>topMethod</code> 的下拉距离阈值（像素）</td>\n<td>Number</td>\n<td></td>\n<td>70</td>\n</tr>\n<tr>\n<td>topMethod</td>\n<td>下拉刷新执行的方法</td>\n<td>Function</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>bottomPullText</td>\n<td><code>bottomStatus</code> 为 <code>pull</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'上拉刷新\'</td>\n</tr>\n<tr>\n<td>bottomDropText</td>\n<td><code>bottomStatus</code> 为 <code>drop</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'释放更新\'</td>\n</tr>\n<tr>\n<td>bottomLoadingText</td>\n<td><code>bottomStatus</code> 为 <code>loading</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'加载中...\'</td>\n</tr>\n<tr>\n<td>bottomDistance</td>\n<td>触发 <code>bottomMethod</code> 的上拉距离阈值（像素）</td>\n<td>Number</td>\n<td></td>\n<td>70</td>\n</tr>\n<tr>\n<td>bottomMethod</td>\n<td>上拉刷新执行的方法</td>\n<td>Function</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>bottomAllLoaded</td>\n<td>若为真，则 <code>bottomMethod</code> 不会被再次触发</td>\n<td>Boolean</td>\n<td></td>\n<td>false</td>\n</tr>\n</tbody>\n</table></div><h2>Events</h2>\n<div class="table-container"><table class="table"><thead>\n<tr>\n<th>事件名称</th>\n<th>说明</th>\n<th>回调参数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>top-status-change</td>\n<td>组件顶部状态发生变化时的回调函数</td>\n<td>组件顶部的新状态名</td>\n</tr>\n<tr>\n<td>bottom-status-change</td>\n<td>组件底部状态发生变化时的回调函数</td>\n<td>组件底部的新状态名</td>\n</tr>\n</tbody>\n</table></div><h2>Slot</h2>\n<div class="table-container"><table class="table"><thead>\n<tr>\n<th>name</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-</td>\n<td>数据列表</td>\n</tr>\n<tr>\n<td>top</td>\n<td>自定义顶部加载提示区域 HTML 模板</td>\n</tr>\n<tr>\n<td>bottom</td>\n<td>自定义底部加载提示区域 HTML 模板</td>\n</tr>\n</tbody>\n</table></div>')},147:function(t,s){"use strict";Object.defineProperty(s,"__esModule",{value:!0}),s["default"]={data:function(){return{topStatus:""}},methods:{handleTopChange:function(t){this.topStatus=t}}}},152:function(t,s){t.exports=" <mt-loadmore :top-method=loadTop @top-status-change=handleTopChange> <ul> <li v-for=\"item in list\">{{ item }}</li> </ul> <div slot=top class=mint-loadmore-top> <span v-show=\"topStatus !== 'loading'\" :class=\"{ 'rotate': topStatus === 'drop' }\">↓</span> <span v-show=\"topStatus === 'loading'\">Loading...</span> </div> </mt-loadmore> "},258:function(t,s,n){var a,d,o={};a=n(147),d=n(152),t.exports=a||{},t.exports.__esModule&&(t.exports=t.exports["default"]);var l="function"==typeof t.exports?t.exports.options||(t.exports.options={}):t.exports;d&&(l.template=d),l.computed||(l.computed={}),Object.keys(o).forEach(function(t){var s=o[t];l.computed[t]=function(){return s}})}});